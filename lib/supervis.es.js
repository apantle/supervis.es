// Generated by CoffeeScript 1.6.1
(function() {
  var Monad, exports, root, sequence,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  root = this;

  Monad = (function() {

    function Monad(methods) {
      var body, name;
      for (name in methods) {
        if (!__hasProp.call(methods, name)) continue;
        body = methods[name];
        this[name] = body;
      }
    }

    Monad.prototype.lift = function(fn) {
      return function(value) {
        return this.bind(fn)(this.unit(value));
      };
    };

    return Monad;

  })();

  Monad.Identity = new Monad({
    unit: function(value) {
      return value;
    },
    bind: function(fn) {
      return fn;
    }
  });

  Monad.Maybe = new Monad({
    unit: function(value) {
      return value;
    },
    bind: function(fn) {
      return function(boundValue) {
        if (boundValue === null || boundValue === void 0) {
          return boundValue;
        } else {
          return fn(boundValue);
        }
      };
    }
  });

  Monad.Writer = new Monad({
    unit: function(value) {
      return [value, ''];
    },
    bind: function(fn) {
      return function(_arg) {
        var newlyWritten, result, value, writtenSoFar, _ref;
        value = _arg[0], writtenSoFar = _arg[1];
        _ref = fn(value), result = _ref[0], newlyWritten = _ref[1];
        return [result, writtenSoFar + newlyWritten];
      };
    }
  });

  Monad.List = new Monad({
    unit: function(value) {
      return [value];
    },
    bind: function(fn) {
      return function(values) {
        return values.reduce((function(ma, b) {
          return Monad.List.plus(ma, fn(b));
        }), Monad.List.zero());
      };
    },
    zero: function() {
      return [];
    },
    plus: function(ma, mb) {
      return ma.concat(mb);
    }
  });

  sequence = function() {
    var args, boundFns, fns, monad;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args[0] instanceof Monad) {
      monad = args[0], fns = 2 <= args.length ? __slice.call(args, 1) : [];
    } else {
      monad = Monad.Identity;
      fns = args;
    }
    boundFns = fns.map(monad.bind);
    return function(value) {
      return boundFns.reduce((function(acc, boundFn) {
        return boundFn(acc);
      }), monad.unit(value));
    };
  };

  root.sequence = sequence;

  root.Monad = Monad;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && (module.exports != null)) {
      exports = module.exports = root;
    }
    exports.supervis = {
      es: root
    };
  } else {
    root.supervis = {
      es: root
    };
  }

}).call(this);
