// Generated by CoffeeScript 1.6.1
(function() {
  var Monad, Promise, exports, fluent, root, sequence, tap,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  root = this;

  Promise = require('promise');

  fluent = function(method) {
    return function() {
      method.apply(this, arguments);
      return this;
    };
  };

  tap = function(value, fn) {
    fn(value);
    return value;
  };

  Monad = (function() {

    function Monad(methods) {
      var body, name;
      for (name in methods) {
        if (!__hasProp.call(methods, name)) continue;
        body = methods[name];
        this[name] = body;
      }
      this.mReturn || (this.mReturn = function(value) {
        return value;
      });
      this.fmap || (this.fmap = function(fn) {
        return fn;
      });
      this.join || (this.join = function(mValue) {
        return mValue;
      });
      this.mBind || (this.mBind = function(mValue, fn) {
        return this.join(this.fmap(fn)(mValue));
      });
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        body = this[name];
        this[name] = body.bind(this);
      }
    }

    return Monad;

  })();

  Monad.Identity = new Monad();

  Monad.Maybe = new Monad({
    fmap: function(fn) {
      return function(mValue) {
        if (mValue === null || mValue === void 0) {
          return mValue;
        } else {
          return fn(mValue);
        }
      };
    }
  });

  Monad.Writer = new Monad({
    mReturn: function(value) {
      return [value, ''];
    },
    fmap: function(fn) {
      return function(_arg) {
        var newlyWritten, result, value, writtenSoFar, _ref;
        value = _arg[0], writtenSoFar = _arg[1];
        _ref = fn(value), result = _ref[0], newlyWritten = _ref[1];
        return [result, writtenSoFar + newlyWritten];
      };
    }
  });

  Monad.List = new Monad({
    mReturn: function(value) {
      return [value];
    },
    join: function(mValue) {
      return mValue.reduce(this.plus, this.zero());
    },
    fmap: function(fn) {
      return function(mValue) {
        return mValue.map(fn);
      };
    },
    zero: function() {
      return [];
    },
    plus: function(ma, mb) {
      return ma.concat(mb);
    }
  });

  Monad.Promise = new Monad({
    mReturn: function(value) {
      return new Promise(function(resolve, reject) {
        return resolve(value);
      });
    },
    fmap: function(fnReturningAPromise) {
      return function(promiseIn) {
        return new Promise(function(resolvePromiseOut, rejectPromiseOut) {
          return promiseIn.then((function(value) {
            return fnReturningAPromise(value).then(resolvePromiseOut, rejectPromiseOut);
          }), rejectPromiseOut);
        });
      };
    }
  });

  sequence = function() {
    var args, fns, monad;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args[0] instanceof Monad) {
      monad = args[0], fns = 2 <= args.length ? __slice.call(args, 1) : [];
    } else {
      monad = Monad.Identity;
      fns = args;
    }
    return function(value) {
      return fns.reduce(monad.mBind, monad.mReturn(value));
    };
  };

  root.sequence = sequence;

  root.Monad = Monad;

  root.Promise = Promise;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && (module.exports != null)) {
      exports = module.exports = root;
    }
    exports.supervis = {
      es: root
    };
  } else {
    root.supervis = {
      es: root
    };
  }

}).call(this);
