// Generated by CoffeeScript 1.6.1
(function() {
  var Monad, Promise, exports, fluent, root, sequence,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  root = this;

  fluent = function(method) {
    return function() {
      method.apply(this, arguments);
      return this;
    };
  };

  Monad = (function() {

    function Monad(methods) {
      var body, name;
      for (name in methods) {
        if (!__hasProp.call(methods, name)) continue;
        body = methods[name];
        this[name] = body;
      }
      this.mReturn || (this.mReturn = function(value) {
        return value;
      });
      this.fmap || (this.fmap = function(fn) {
        return fn;
      });
      this.join || (this.join = function(mValue) {
        return mValue;
      });
      this.mBind || (this.mBind = function(mValue, fn) {
        return this.join(this.fmap(fn)(mValue));
      });
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        body = this[name];
        this[name] = body.bind(this);
      }
    }

    return Monad;

  })();

  Monad.Identity = new Monad();

  Monad.Maybe = new Monad({
    fmap: function(fn) {
      return function(mValue) {
        if (mValue === null || mValue === void 0) {
          return mValue;
        } else {
          return fn(mValue);
        }
      };
    }
  });

  Monad.Writer = new Monad({
    mReturn: function(value) {
      return [value, ''];
    },
    fmap: function(fn) {
      return function(_arg) {
        var newlyWritten, result, value, writtenSoFar, _ref;
        value = _arg[0], writtenSoFar = _arg[1];
        _ref = fn(value), result = _ref[0], newlyWritten = _ref[1];
        return [result, writtenSoFar + newlyWritten];
      };
    }
  });

  Monad.List = new Monad({
    mReturn: function(value) {
      return [value];
    },
    join: function(mValue) {
      return mValue.reduce(this.plus, this.zero());
    },
    fmap: function(fn) {
      return function(mValue) {
        return mValue.map(fn);
      };
    },
    zero: function() {
      return [];
    },
    plus: function(ma, mb) {
      return ma.concat(mb);
    }
  });

  Promise = (function() {
    var STATE;

    Promise.schedule = function(thunk) {
      if ((typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null) {
        return process.nextTick(thunk);
      } else if ((typeof window !== "undefined" && window !== null ? window.setTimeout : void 0) != null) {
        return window.setTimeout(thunk, 0);
      } else if (typeof setTimeout !== "undefined" && setTimeout !== null) {
        return setTimout(thunk, 0);
      }
    };

    Promise.immediate = function(value) {
      return new Promise().resolve(value);
    };

    STATE = {
      unfulfilled: {
        then: function(promise, onResolved, onRejected) {},
        resolve: function(promise, value) {
          var handler, _i, _len, _ref, _results;
          promise.state = STATE.resolved;
          promise.value = value;
          _ref = promise.onResolveds;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            handler = _ref[_i];
            _results.push(Promise.schedule(function() {
              return handler(promise.value);
            }));
          }
          return _results;
        },
        reject: function(promise, error) {
          var handler, _i, _len, _ref, _results;
          promise.state = STATE.rejected;
          promise.error = error;
          _ref = promise.onRejecteds;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            handler = _ref[_i];
            _results.push(Promise.schedule(function() {
              return handler(promise.error);
            }));
          }
          return _results;
        }
      },
      resolved: {
        then: function(promise, onResolved, onRejected) {
          return Promise.schedule(function() {
            if (onResolved != null) {
              return onResolved(promise.value);
            }
          });
        },
        resolve: function(promise, value) {},
        reject: function(promise, error) {
          throw "already resolved, cannot reject";
        }
      },
      rejected: {
        then: function(promise, onResolved, onRejected) {
          return Promise.schedule(function() {
            if (onRejected != null) {
              return onRejected(promise.error);
            }
          });
        },
        resolve: function(promise, value) {
          throw "already rejected, cannot resolved";
        },
        reject: function(promise, error) {}
      }
    };

    function Promise() {
      this.state = STATE.unfulfilled;
      this.onResolveds = [];
      this.onRejecteds = [];
    }

    Promise.prototype.then = fluent(function(onResolved, onRejected) {
      if (onResolved != null) {
        this.onResolveds.push(onResolved);
      }
      if (onRejected != null) {
        this.onRejecteds.push(onRejected);
      }
      return this.state.then(this, onResolved, onRejected);
    });

    Promise.prototype.resolve = fluent(function(value) {
      return this.state.resolve(this, value);
    });

    Promise.prototype.reject = fluent(function(error) {
      return this.state.reject(this, error);
    });

    return Promise;

  })();

  Monad.Promise = new Monad({
    mReturn: function(value) {
      return Promise.immediate(value);
    },
    fmap: function(fnReturningAPromise) {
      return function(promise) {
        var p;
        p = new Promise();
        promise.then(function(value) {
          return fnReturningAPromise(value).then(function(newValue) {
            return p.resolve(newValue);
          });
        });
        return p;
      };
    }
  });

  sequence = function() {
    var args, fns, monad;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args[0] instanceof Monad) {
      monad = args[0], fns = 2 <= args.length ? __slice.call(args, 1) : [];
    } else {
      monad = Monad.Identity;
      fns = args;
    }
    return function(value) {
      return fns.reduce(monad.mBind, monad.mReturn(value));
    };
  };

  root.sequence = sequence;

  root.Monad = Monad;

  root.Promise = Promise;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && (module.exports != null)) {
      exports = module.exports = root;
    }
    exports.supervis = {
      es: root
    };
  } else {
    root.supervis = {
      es: root
    };
  }

}).call(this);
